<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Array Visualizer - Interactive 1D, 2D, 3D Array Learning Tool</title>
    <meta name="description" content="Interactive Java array visualizer for learning 1D, 2D, and 3D arrays. Visualize array indexing, explore data structures, and understand Java programming concepts with real-time highlighting and 3D visualization.">
    <meta name="keywords" content="java array, array visualizer, java programming, data structures, 1D array, 2D array, 3D array, java tutorial, programming education, interactive learning, array indexing, java arrays visualization">
    <meta name="author" content="Java Array Visualizer">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://yoursite.com/java-array-visualizer.html">

    <!-- Open Graph meta tags for social sharing -->
    <meta property="og:title" content="Java Array Visualizer - Interactive Learning Tool">
    <meta property="og:description" content="Learn Java arrays with interactive 1D, 2D, and 3D visualizations. Perfect for students and developers learning data structures.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://yoursite.com/java-array-visualizer.html">
    <meta property="og:image" content="https://yoursite.com/java-array-visualizer-preview.png">
    <meta property="og:site_name" content="Java Array Visualizer">

    <!-- Twitter Card meta tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Java Array Visualizer - Interactive Learning Tool">
    <meta name="twitter:description" content="Learn Java arrays with interactive 1D, 2D, and 3D visualizations. Perfect for students and developers.">
    <meta name="twitter:image" content="https://yoursite.com/java-array-visualizer-preview.png">

    <!-- Structured Data for SEO -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Java Array Visualizer",
        "description": "Interactive educational tool for learning Java arrays with 1D, 2D, and 3D visualizations",
        "url": "https://yoursite.com/java-array-visualizer.html",
        "applicationCategory": "EducationalApplication",
        "operatingSystem": "Web Browser",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "creator": {
            "@type": "Organization",
            "name": "Java Array Visualizer"
        },
        "educationalLevel": "Beginner to Intermediate",
        "teaches": [
            "Java Arrays",
            "Data Structures",
            "Array Indexing",
            "Programming Fundamentals"
        ],
        "keywords": "java array visualizer, programming education, data structures, interactive learning"
    }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .logo-icon {
            display: inline-block;
            font-size: 1.2em;
            filter: drop-shadow(0 0 8px rgba(245, 87, 108, 0.6));
            animation: subtle-glow 3s ease-in-out infinite alternate;
        }

        @keyframes subtle-glow {
            0% {
                filter: drop-shadow(0 0 8px rgba(245, 87, 108, 0.4));
            }
            100% {
                filter: drop-shadow(0 0 12px rgba(245, 87, 108, 0.8));
            }
        }

        .controls {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            display: inline-block;
            margin: 10px 15px;
        }

        label {
            font-weight: bold;
            color: #555;
            margin-right: 8px;
        }

        select, input[type="number"], button {
            padding: 8px 15px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        select:hover, input[type="number"]:hover {
            border-color: #764ba2;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            border: none;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .code-section, .visualization-section {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .code-display {
            background: #f8f9fa;
            color: #333;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            overflow-x: auto;
            margin-top: 10px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid #dee2e6;
            white-space: pre;
        }

        .keyword {
            color: #0066cc;
            font-weight: bold;
        }

        .type {
            color: #008000;
        }

        .number {
            color: #8b00ff;
        }

        .comment {
            color: #666666;
            font-style: italic;
        }

        .string {
            color: #b8860b;
        }

        .highlight-code {
            background: rgba(255, 235, 59, 0.4);
            padding: 2px 4px;
            border-radius: 3px;
        }

        .array-1d {
            display: flex;
            gap: 5px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .array-cell {
            border: 2px solid #667eea;
            padding: 15px;
            min-width: 50px;
            text-align: center;
            background: white;
            border-radius: 8px;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
        }

        .array-cell.highlighted {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            transform: scale(1.2);
            z-index: 10;
            box-shadow: 0 5px 20px rgba(240, 147, 251, 0.5);
        }

        .array-cell.dimmed {
            opacity: 0.3;
            transform: scale(0.95);
        }

        .array-2d {
            display: inline-block;
            margin: 20px 0;
        }

        .array-row {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }

        .index-label {
            font-size: 10px;
            color: #999;
            position: absolute;
            top: -8px;
            right: 2px;
        }

        #canvas3d {
            border: 2px solid #667eea;
            border-radius: 10px;
            cursor: grab;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        }
        
        #canvas3d:active {
            cursor: grabbing;
        }


        h2 {
            color: #667eea;
            margin: 15px 0;
            font-size: 1.3em;
        }

        .canvas-controls {
            text-align: center;
            margin: 10px 0;
        }

        .canvas-info {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-top: 10px;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            border-top: 1px solid #dee2e6;
            color: #666;
            font-size: 14px;
        }

        footer a {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
        }

        footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <main class="container">
        <header>
            <h1><span class="logo-icon">üßä</span> Java Array Visualizer</h1>
        </header>

        <section class="controls" aria-label="Array Configuration Controls">
            <div class="control-group">
                <label for="arrayType">Array Type:</label>
                <select id="arrayType" aria-describedby="arrayTypeHelp">
                    <option value="1D">1D Array</option>
                    <option value="2D">2D Array</option>
                    <option value="3D">3D Array</option>
                </select>
                <span id="arrayTypeHelp" class="sr-only">Select the type of array to visualize</span>
            </div>

            <div class="control-group">
                <label for="sizeI">Size (i):</label>
                <input type="number" id="sizeI" value="5" min="1" max="10" aria-describedby="sizeIHelp">
                <span id="sizeIHelp" class="sr-only">Set the size of the first dimension (1-10)</span>
            </div>

            <div class="control-group" id="sizeJGroup" style="display:none;">
                <label for="sizeJ">Size (j):</label>
                <input type="number" id="sizeJ" value="4" min="1" max="10" aria-describedby="sizeJHelp">
                <span id="sizeJHelp" class="sr-only">Set the size of the second dimension (1-10)</span>
            </div>

            <div class="control-group" id="sizeKGroup" style="display:none;">
                <label for="sizeK">Size (k):</label>
                <input type="number" id="sizeK" value="3" min="1" max="10" aria-describedby="sizeKHelp">
                <span id="sizeKHelp" class="sr-only">Set the size of the third dimension (1-10)</span>
            </div>

            <br>

            <div class="control-group">
                <label for="indexI">Access Index (i):</label>
                <input type="number" id="indexI" value="0" min="0" aria-describedby="indexIHelp">
                <span id="indexIHelp" class="sr-only">Select which element to highlight in the first dimension</span>
            </div>

            <div class="control-group" id="indexJGroup" style="display:none;">
                <label for="indexJ">Index (j):</label>
                <input type="number" id="indexJ" value="0" min="0" aria-describedby="indexJHelp">
                <span id="indexJHelp" class="sr-only">Select which element to highlight in the second dimension</span>
            </div>

            <div class="control-group" id="indexKGroup" style="display:none;">
                <label for="indexK">Index (k):</label>
                <input type="number" id="indexK" value="0" min="0" aria-describedby="indexKHelp">
                <span id="indexKHelp" class="sr-only">Select which element to highlight in the third dimension</span>
            </div>

        </section>

        <section class="main-content" aria-label="Array Visualization">
            <article class="code-section">
                <h2>üìù Java Code</h2>
                <div id="codeDisplay" class="code-display" role="region" aria-label="Generated Java Code"></div>
            </article>

            <article class="visualization-section">
                <h2>üé® Visualization</h2>
                <div id="visualization" role="region" aria-label="Array Visual Representation"></div>
                <div id="canvasControls" class="canvas-controls" style="display:none;">
                    <button id="resetViewBtn" aria-label="Reset 3D view to default position">üéØ Reset View</button>
                    <div class="canvas-info">Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ [0][0][0] starts at top-left</div>
                </div>
            </article>
        </section>

        <footer>
            <p>Email <a href="mailto:guosite@gmail.com">guosite@gmail.com</a> for feedback</p>
        </footer>
    </main>

    <script>
        let currentArray = [];
        let arrayType = '1D';
        
        // 3D visualization variables - default view with [0][0][0] at top-left
        let rotation = { x: Math.PI / 6, y: -Math.PI / 4 };
        let zoom = 1;
        let isDragging = false;
        let lastMousePos = { x: 0, y: 0 };

        function initArray() {
            arrayType = document.getElementById('arrayType').value;
            const sizeI = parseInt(document.getElementById('sizeI').value);
            const sizeJ = parseInt(document.getElementById('sizeJ').value);
            const sizeK = parseInt(document.getElementById('sizeK').value);
            
            // Show/hide appropriate controls
            document.getElementById('sizeJGroup').style.display = arrayType !== '1D' ? 'inline-block' : 'none';
            document.getElementById('sizeKGroup').style.display = arrayType === '3D' ? 'inline-block' : 'none';
            document.getElementById('indexJGroup').style.display = arrayType !== '1D' ? 'inline-block' : 'none';
            document.getElementById('indexKGroup').style.display = arrayType === '3D' ? 'inline-block' : 'none';
            document.getElementById('canvasControls').style.display = arrayType === '3D' ? 'block' : 'none';
            
            // Initialize array with random values
            if (arrayType === '1D') {
                currentArray = Array(sizeI).fill(0).map(() => Math.floor(Math.random() * 100));
            } else if (arrayType === '2D') {
                currentArray = Array(sizeI).fill(0).map(() => 
                    Array(sizeJ).fill(0).map(() => Math.floor(Math.random() * 100))
                );
            } else {
                currentArray = Array(sizeI).fill(0).map(() => 
                    Array(sizeJ).fill(0).map(() => 
                        Array(sizeK).fill(0).map(() => Math.floor(Math.random() * 100))
                    )
                );
            }
            
            updateIndexBounds();
            updateCodeDisplay();
            visualizeArray();
            highlightElement();
        }

        function updateIndexBounds() {
            const sizeI = parseInt(document.getElementById('sizeI').value);
            const sizeJ = parseInt(document.getElementById('sizeJ').value);
            const sizeK = parseInt(document.getElementById('sizeK').value);

            // Update max attributes for index inputs based on array size
            const indexIInput = document.getElementById('indexI');
            indexIInput.max = Math.max(0, sizeI - 1);

            if (arrayType !== '1D') {
                const indexJInput = document.getElementById('indexJ');
                indexJInput.max = Math.max(0, sizeJ - 1);
            }

            if (arrayType === '3D') {
                const indexKInput = document.getElementById('indexK');
                indexKInput.max = Math.max(0, sizeK - 1);
            }

            // Clamp current values to valid range
            clampIndexValues();
        }

        function clampIndexValues() {
            const indexIInput = document.getElementById('indexI');
            const indexJInput = document.getElementById('indexJ');
            const indexKInput = document.getElementById('indexK');

            // Clamp indexI
            let currentI = parseInt(indexIInput.value);
            const maxI = parseInt(indexIInput.max);
            if (isNaN(currentI) || currentI < 0) currentI = 0;
            if (currentI > maxI) currentI = maxI;
            indexIInput.value = currentI;

            // Clamp indexJ if applicable
            if (arrayType !== '1D') {
                let currentJ = parseInt(indexJInput.value);
                const maxJ = parseInt(indexJInput.max);
                if (isNaN(currentJ) || currentJ < 0) currentJ = 0;
                if (currentJ > maxJ) currentJ = maxJ;
                indexJInput.value = currentJ;
            }

            // Clamp indexK if applicable
            if (arrayType === '3D') {
                let currentK = parseInt(indexKInput.value);
                const maxK = parseInt(indexKInput.max);
                if (isNaN(currentK) || currentK < 0) currentK = 0;
                if (currentK > maxK) currentK = maxK;
                indexKInput.value = currentK;
            }
        }

        function onIndexInput(event) {
            // Real-time validation as user types
            const input = event.target;
            let value = parseInt(input.value);
            const min = parseInt(input.min) || 0;
            const max = parseInt(input.max) || 0;

            if (isNaN(value)) return;

            if (value < min) {
                input.value = min;
            } else if (value > max) {
                input.value = max;
            }

            // Automatically highlight as user types
            highlightElement();
        }

        function onIndexChange(event) {
            // Validate and update visualization when input changes
            clampIndexValues();
            highlightElement();
        }

        function updateCodeDisplay() {
            const indexI = parseInt(document.getElementById('indexI').value);
            const indexJ = parseInt(document.getElementById('indexJ').value);
            const indexK = parseInt(document.getElementById('indexK').value);
            
            let code = '';
            
            if (arrayType === '1D') {
                // Build initializer list
                let initList = currentArray.map((val, i) => {
                    if (i === indexI) {
                        return `<span class="number highlight-code">${val}</span>`;
                    }
                    return `<span class="number">${val}</span>`;
                }).join(', ');
                
                code = `
<span class="keyword">int</span>[] <span class="type">array</span> = {${initList}};`;
            } else if (arrayType === '2D') {
                // Build 2D initializer list
                let initList = currentArray.map((row, i) => {
                    let rowStr = row.map((val, j) => {
                        if (i === indexI && j === indexJ) {
                            return `<span class="number highlight-code">${val}</span>`;
                        }
                        return `<span class="number">${val}</span>`;
                    }).join(', ');
                    return `    {${rowStr}}`;
                }).join(',\n');

                code = `<span class="keyword">int</span>[][] <span class="type">array</span> = {
${initList}
};`;
            } else {
                // Build 3D initializer list with proper formatting
                let initList = currentArray.map((plane, i) => {
                    let planeStr = plane.map((row, j) => {
                        let rowStr = row.map((val, k) => {
                            if (i === indexI && j === indexJ && k === indexK) {
                                return `<span class="number highlight-code">${val}</span>`;
                            }
                            return `<span class="number">${val}</span>`;
                        }).join(', ');
                        return `        {${rowStr}}`;
                    }).join(',\n');
                    return `    {\n${planeStr}\n    }`;
                }).join(',\n');

                code = `<span class="keyword">int</span>[][][] <span class="type">array</span> = {
${initList}
};`;
            }
            
            document.getElementById('codeDisplay').innerHTML = code;
        }

        function visualizeArray() {
            const viz = document.getElementById('visualization');
            
            if (arrayType === '1D') {
                let html = '<div class="array-1d">';
                currentArray.forEach((val, i) => {
                    html += `<div class="array-cell" data-index="${i}">
                        <span class="index-label">[${i}]</span>
                        ${val}
                    </div>`;
                });
                html += '</div>';
                viz.innerHTML = html;
            } else if (arrayType === '2D') {
                let html = '<div class="array-2d">';
                currentArray.forEach((row, i) => {
                    html += '<div class="array-row">';
                    row.forEach((val, j) => {
                        html += `<div class="array-cell" data-i="${i}" data-j="${j}">
                            <span class="index-label">[${i}][${j}]</span>
                            ${val}
                        </div>`;
                    });
                    html += '</div>';
                });
                html += '</div>';
                viz.innerHTML = html;
            } else {
                viz.innerHTML = '<canvas id="canvas3d" width="600" height="400"></canvas>';
                setup3DCanvas();
                draw3DArray();
            }
        }
        
        function setup3DCanvas() {
            const canvas = document.getElementById('canvas3d');
            if (!canvas) return;
            
            // Mouse drag for rotation
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMousePos = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaX = e.clientX - lastMousePos.x;
                const deltaY = e.clientY - lastMousePos.y;
                
                rotation.y += deltaX * 0.01;
                rotation.x -= deltaY * 0.01;
                
                // Limit vertical rotation to prevent flipping
                rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.x));
                
                lastMousePos = { x: e.clientX, y: e.clientY };
                draw3DArray();
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            // Mouse wheel for zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                zoom *= e.deltaY > 0 ? 0.9 : 1.1;
                zoom = Math.max(0.5, Math.min(3, zoom));
                draw3DArray();
            });
        }

        function setup3DCanvas() {
            const canvas = document.getElementById('canvas3d');
            if (!canvas) return;
            
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMousePos = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaX = e.clientX - lastMousePos.x;
                const deltaY = e.clientY - lastMousePos.y;
                
                rotation.y += deltaX * 0.01;
                rotation.x -= deltaY * 0.01;
                
                lastMousePos = { x: e.clientX, y: e.clientY };
                draw3DArray();
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                zoom *= e.deltaY > 0 ? 0.9 : 1.1;
                zoom = Math.max(0.5, Math.min(3, zoom));
                draw3DArray();
            });
        }

                

        function draw3DArray() {
            const canvas = document.getElementById('canvas3d');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const cellSize = 40 * zoom;
            const gap = 15 * zoom; // Gap between cubes
            
            const indexI = parseInt(document.getElementById('indexI').value);
            const indexJ = parseInt(document.getElementById('indexJ').value);
            const indexK = parseInt(document.getElementById('indexK').value);
            
            // Check if we're highlighting a specific element
            const hasHighlight = indexI < currentArray.length &&
                                indexJ < currentArray[0].length &&
                                indexK < currentArray[0][0].length &&
                                indexI >= 0 && indexJ >= 0 && indexK >= 0;

            // Calculate positions for all cubes
            // Adjust positioning so [0][0][0] is at top-left-front
            let cubes = [];
            for (let i = 0; i < currentArray.length; i++) {
                for (let j = 0; j < currentArray[i].length; j++) {
                    for (let k = 0; k < currentArray[i][j].length; k++) {
                        // Position cubes with [0][0][0] at origin
                        const x = k * (cellSize + gap);
                        const y = j * (cellSize + gap);
                        const z = i * (cellSize + gap);

                        const isHighlighted = hasHighlight && (i === indexI && j === indexJ && k === indexK);

                        // Check if cube is on the outer surface
                        const isOuter = i === 0 || i === currentArray.length - 1 ||
                                      j === 0 || j === currentArray[i].length - 1 ||
                                      k === 0 || k === currentArray[i][j].length - 1;

                        // Calculate 3D position for each vertex of the cube
                        const vertices = calculate3DVertices(x, y, z, cellSize, rotation);

                        cubes.push({
                            vertices,
                            x, y, z,
                            value: currentArray[i][j][k],
                            i, j, k,
                            isHighlighted,
                            isOuter
                        });
                    }
                }
            }
            
            // Sort by depth, but always draw highlighted cubes last (on top)
            cubes.sort((a, b) => {
                // Highlighted cubes always come last
                if (a.isHighlighted && !b.isHighlighted) return 1;
                if (!a.isHighlighted && b.isHighlighted) return -1;

                // Otherwise sort by z-depth (back to front)
                const avgZA = (a.vertices[0].z + a.vertices[6].z) / 2;
                const avgZB = (b.vertices[0].z + b.vertices[6].z) / 2;
                return avgZA - avgZB;
            });
            
            // Draw cubes
            cubes.forEach(cube => {
                // Calculate visibility and opacity
                let alpha = 1;
                let showValue = false;

                if (cube.isHighlighted) {
                    // Highlighted cube is fully visible
                    alpha = 1;
                    showValue = true;
                } else if (hasHighlight) {
                    // When something is highlighted, make other cubes very transparent
                    alpha = 0.15;
                    showValue = false;
                } else {
                    // Normal state - show outer cubes solid, inner cubes semi-transparent
                    if (cube.isOuter) {
                        alpha = 1;
                        showValue = true;
                    } else {
                        alpha = 0.2;
                        showValue = false;
                    }
                }

                // Determine color based on state
                let baseColor = '#667eea';
                if (cube.isHighlighted) {
                    baseColor = '#f5576c';
                }

                // Draw the complete 3D cube
                drawFullCube(ctx, cube.vertices, centerX, centerY, baseColor, alpha, cube.value, showValue, `[${cube.i}][${cube.j}][${cube.k}]`);
            });
        }
        
        function calculate3DVertices(x, y, z, size, rotation) {
            const halfSize = size / 2;
            
            // Define the 8 vertices of a cube
            const vertices = [
                { x: x - halfSize, y: y - halfSize, z: z - halfSize }, // 0: front-top-left
                { x: x + halfSize, y: y - halfSize, z: z - halfSize }, // 1: front-top-right
                { x: x + halfSize, y: y + halfSize, z: z - halfSize }, // 2: front-bottom-right
                { x: x - halfSize, y: y + halfSize, z: z - halfSize }, // 3: front-bottom-left
                { x: x - halfSize, y: y - halfSize, z: z + halfSize }, // 4: back-top-left
                { x: x + halfSize, y: y - halfSize, z: z + halfSize }, // 5: back-top-right
                { x: x + halfSize, y: y + halfSize, z: z + halfSize }, // 6: back-bottom-right
                { x: x - halfSize, y: y + halfSize, z: z + halfSize }, // 7: back-bottom-left
            ];
            
            // Apply rotation to each vertex
            return vertices.map(v => {
                // Rotate around Y axis
                const rotX = v.x * Math.cos(rotation.y) - v.z * Math.sin(rotation.y);
                const rotZ = v.x * Math.sin(rotation.y) + v.z * Math.cos(rotation.y);
                
                // Rotate around X axis
                const rotY = v.y * Math.cos(rotation.x) - rotZ * Math.sin(rotation.x);
                const finalZ = v.y * Math.sin(rotation.x) + rotZ * Math.cos(rotation.x);
                
                return { x: rotX, y: rotY, z: finalZ };
            });
        }
        
        function drawFullCube(ctx, vertices, centerX, centerY, color, alpha, value, showValue, indices) {
            // Project 3D coordinates to 2D with centering offset
            // Offset to center the entire cube array in the canvas
            const offsetX = -150 * zoom;
            const offsetY = -50 * zoom;
            
            const projected = vertices.map(v => ({
                x: centerX + v.x + offsetX,
                y: centerY + v.y + offsetY,
                z: v.z
            }));
            
            // Convert hex color to RGB
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            
            // Define faces with their vertex indices and normal direction for shading
            const faces = [
                { indices: [4, 5, 6, 7], shade: 0.3 },  // back (darkest)
                { indices: [0, 4, 7, 3], shade: 0.5 },  // left
                { indices: [1, 2, 6, 5], shade: 0.7 },  // right
                { indices: [3, 7, 6, 2], shade: 0.6 },  // bottom
                { indices: [0, 1, 5, 4], shade: 1.2 },  // top (brightest)
                { indices: [0, 3, 2, 1], shade: 1.0 },  // front
            ];
            
            // Calculate face depths for sorting
            const facesWithDepth = faces.map(face => {
                const avgZ = face.indices.reduce((sum, idx) => sum + projected[idx].z, 0) / face.indices.length;
                return { ...face, avgZ };
            });
            
            // Sort faces by depth (back to front)
            facesWithDepth.sort((a, b) => a.avgZ - b.avgZ);
            
            // Draw each face
            facesWithDepth.forEach(face => {
                const faceShade = face.shade;
                
                // Calculate face color with shading
                const faceR = Math.min(255, r * faceShade);
                const faceG = Math.min(255, g * faceShade);
                const faceB = Math.min(255, b * faceShade);
                
                // Draw face
                ctx.fillStyle = `rgba(${faceR}, ${faceG}, ${faceB}, ${alpha})`;
                ctx.beginPath();
                ctx.moveTo(projected[face.indices[0]].x, projected[face.indices[0]].y);
                for (let i = 1; i < face.indices.length; i++) {
                    ctx.lineTo(projected[face.indices[i]].x, projected[face.indices[i]].y);
                }
                ctx.closePath();
                ctx.fill();
                
                // Draw face outline
                ctx.strokeStyle = `rgba(0, 0, 0, ${alpha * 0.3})`;
                ctx.lineWidth = 1;
                ctx.stroke();
            });
            
            // Draw edges for better definition (only for highlighted cubes)
            if (alpha > 0.5) {
                ctx.strokeStyle = `rgba(0, 0, 0, ${alpha * 0.5})`;
                ctx.lineWidth = 2;
                
                // Draw all 12 edges
                const edges = [
                    [0, 1], [1, 2], [2, 3], [3, 0], // front face
                    [4, 5], [5, 6], [6, 7], [7, 4], // back face
                    [0, 4], [1, 5], [2, 6], [3, 7]  // connecting edges
                ];
                
                edges.forEach(edge => {
                    ctx.beginPath();
                    ctx.moveTo(projected[edge[0]].x, projected[edge[0]].y);
                    ctx.lineTo(projected[edge[1]].x, projected[edge[1]].y);
                    ctx.stroke();
                });
            }
            
            // Draw value on the front face if visible
            if (showValue) {
                // Calculate center of front face
                const frontCenterX = (projected[0].x + projected[1].x + projected[2].x + projected[3].x) / 4;
                const frontCenterY = (projected[0].y + projected[1].y + projected[2].y + projected[3].y) / 4;
                
                // Add shadow for better readability
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${16 * zoom}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(value, frontCenterX, frontCenterY);
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Draw indices above the cube
                const topCenterX = (projected[0].x + projected[1].x + projected[4].x + projected[5].x) / 4;
                const topCenterY = Math.min(projected[0].y, projected[1].y, projected[4].y, projected[5].y) - 10;
                
                ctx.fillStyle = `rgba(100, 100, 100, ${alpha})`;
                ctx.font = `${10 * zoom}px Arial`;
                ctx.fillText(indices, topCenterX, topCenterY);
            }
        }

        function highlightElement() {
            const indexI = parseInt(document.getElementById('indexI').value);
            const indexJ = parseInt(document.getElementById('indexJ').value);
            const indexK = parseInt(document.getElementById('indexK').value);

            if (arrayType === '1D') {
                const cells = document.querySelectorAll('.array-cell');
                cells.forEach((cell, i) => {
                    cell.classList.remove('highlighted', 'dimmed');
                    if (i === indexI) {
                        cell.classList.add('highlighted');
                    } else {
                        cell.classList.add('dimmed');
                    }
                });
            } else if (arrayType === '2D') {
                const cells = document.querySelectorAll('.array-cell');
                cells.forEach(cell => {
                    const i = parseInt(cell.dataset.i);
                    const j = parseInt(cell.dataset.j);
                    cell.classList.remove('highlighted', 'dimmed');
                    if (i === indexI && j === indexJ) {
                        cell.classList.add('highlighted');
                    } else {
                        cell.classList.add('dimmed');
                    }
                });
            } else {
                draw3DArray();
            }

            updateCodeDisplay();
        }


        function resetView() {
            // Reset to default view with [0][0][0] at top-left
            rotation = { x: Math.PI / 6, y: -Math.PI / 4 };
            zoom = 1;
            draw3DArray();
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Add event listeners
            document.getElementById('arrayType').addEventListener('change', initArray);
            document.getElementById('sizeI').addEventListener('change', initArray);
            document.getElementById('sizeJ').addEventListener('change', initArray);
            document.getElementById('sizeK').addEventListener('change', initArray);
            
            document.getElementById('indexI').addEventListener('change', onIndexChange);
            document.getElementById('indexJ').addEventListener('change', onIndexChange);
            document.getElementById('indexK').addEventListener('change', onIndexChange);
            document.getElementById('indexI').addEventListener('input', onIndexInput);
            document.getElementById('indexJ').addEventListener('input', onIndexInput);
            document.getElementById('indexK').addEventListener('input', onIndexInput);

            document.getElementById('resetViewBtn').addEventListener('click', resetView);
            
            // Initialize array
            initArray();
        });
    </script>
</body>
</html>
