<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Space Shooter</title>
  <style>
    /* Make the page background black so the game blends in */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }
  </style>
</head>
<body>

<!-- Load Phaser 3 from CDN -->
<script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>

<script>
// ============================================================
// SPACE SHOOTER â€” A top-down space shooter built with Phaser 3
// All graphics are drawn with code â€” no image files needed!
// ============================================================

// --- Constants ---
const GAME_WIDTH = 480;    // Width of the game world
const GAME_HEIGHT = 640;   // Height of the game world
const PLAYER_SPEED = 250;  // How fast the player moves (pixels/sec)
const BULLET_SPEED = 400;  // How fast bullets travel upward
const FIRE_RATE = 250;     // Milliseconds between shots
const STARTING_LIVES = 3;  // Player starts with 3 lives

// ============================================================
// HELPER: Create sound effects using the Web Audio API
// We generate simple tones so we don't need any audio files.
// ============================================================
function createShootSound(audioContext) {
  // A short, high-pitched "pew" sound
  return function () {
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(880, audioContext.currentTime);      // Start high
    osc.frequency.exponentialRampToValueAtTime(440, audioContext.currentTime + 0.1); // Drop pitch
    gain.gain.setValueAtTime(0.15, audioContext.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
    osc.connect(gain).connect(audioContext.destination);
    osc.start();
    osc.stop(audioContext.currentTime + 0.1);
  };
}

function createExplosionSound(audioContext) {
  // A short burst of noise that sounds like an explosion
  return function () {
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(150, audioContext.currentTime);
    osc.frequency.exponentialRampToValueAtTime(30, audioContext.currentTime + 0.3);
    gain.gain.setValueAtTime(0.2, audioContext.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
    osc.connect(gain).connect(audioContext.destination);
    osc.start();
    osc.stop(audioContext.currentTime + 0.3);
  };
}

function createGameOverSound(audioContext) {
  // A descending tone that signals "game over"
  return function () {
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(600, audioContext.currentTime);
    osc.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.8);
    gain.gain.setValueAtTime(0.25, audioContext.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);
    osc.connect(gain).connect(audioContext.destination);
    osc.start();
    osc.stop(audioContext.currentTime + 0.8);
  };
}

// ============================================================
// HELPER: Detect if the device has a touchscreen
// ============================================================
function isTouchDevice() {
  return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
}

// ============================================================
// MAIN GAME SCENE â€” This is where all the action happens!
// ============================================================
class GameScene extends Phaser.Scene {
  constructor() {
    super('GameScene');
  }

  // ----------------------------------------------------------
  // CREATE: Runs once when the scene starts.
  // Sets up the player, controls, stars, and groups.
  // ----------------------------------------------------------
  create() {
    // --- Audio setup ---
    // We create an AudioContext once and reuse it for all sounds
    if (!this.game.audioCtx) {
      this.game.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    const ctx = this.game.audioCtx;
    // Resume audio context on first user interaction (browser requirement)
    this.input.once('pointerdown', () => { if (ctx.state === 'suspended') ctx.resume(); });
    this.playShootSound = createShootSound(ctx);
    this.playExplosionSound = createExplosionSound(ctx);
    this.playGameOverSound = createGameOverSound(ctx);

    // --- Game state ---
    this.score = 0;            // Current score
    this.lives = STARTING_LIVES; // Lives remaining
    this.lastFired = 0;        // Timestamp of last bullet fired
    this.gameOver = false;      // Is the game over?
    this.difficultyLevel = 1;  // Increases over time
    this.isInvincible = false; // Brief invincibility after being hit

    // --- Draw the starry background ---
    this.drawStars();

    // --- Create the player ship texture ---
    this.createPlayerTexture();

    // --- Create bullet texture ---
    this.createBulletTexture();

    // --- Create enemy texture ---
    this.createEnemyTextures();

    // --- Player sprite ---
    this.player = this.physics.add.sprite(GAME_WIDTH / 2, GAME_HEIGHT - 80, 'player');
    this.player.setCollideWorldBounds(true); // Can't leave the screen

    // --- Bullet group (reusable pool of bullets) ---
    this.bullets = this.physics.add.group({
      defaultKey: 'bullet',
      maxSize: 30  // Max 30 bullets on screen at once
    });

    // --- Enemy group ---
    this.enemies = this.physics.add.group();

    // --- Particle burst group (for explosions) ---
    this.particles = this.add.group();

    // --- Keyboard controls ---
    this.cursors = this.input.keyboard.createCursorKeys(); // Arrow keys
    this.wasd = {
      up: this.input.keyboard.addKey('W'),
      down: this.input.keyboard.addKey('S'),
      left: this.input.keyboard.addKey('A'),
      right: this.input.keyboard.addKey('D')
    };
    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

    // --- HUD: Score text at the top ---
    this.scoreText = this.add.text(10, 10, 'Score: 0', {
      fontSize: '20px',
      fill: '#ffffff',
      fontFamily: 'monospace'
    }).setScrollFactor(0).setDepth(10);

    // --- HUD: Lives display ---
    this.livesText = this.add.text(GAME_WIDTH - 10, 10, this.getLivesString(), {
      fontSize: '20px',
      fill: '#ffffff'
    }).setOrigin(1, 0).setScrollFactor(0).setDepth(10);

    // --- Difficulty timer: ramp up every 15 seconds ---
    this.time.addEvent({
      delay: 15000,       // Every 15 seconds
      callback: this.increaseDifficulty,
      callbackScope: this,
      loop: true
    });

    // --- Enemy spawn timer ---
    this.enemySpawnTimer = this.time.addEvent({
      delay: 1200,        // Start spawning every 1.2 seconds
      callback: this.spawnEnemy,
      callbackScope: this,
      loop: true
    });

    // --- Collision: bullet hits enemy ---
    this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);

    // --- Collision: enemy hits player ---
    this.physics.add.overlap(this.player, this.enemies, this.enemyHitPlayer, null, this);

    // --- Mobile touch controls ---
    this.touchControls = { left: false, right: false, up: false, down: false, fire: false };
    this.usingTouch = isTouchDevice();
    if (this.usingTouch) {
      this.createTouchControls();
    }

    // --- Flame effect timer (animate the ship's flame) ---
    this.flameVisible = true;
    this.time.addEvent({
      delay: 80,
      callback: () => { this.flameVisible = !this.flameVisible; },
      loop: true
    });
  }

  // ----------------------------------------------------------
  // Draw a starfield on the background
  // ----------------------------------------------------------
  drawStars() {
    const gfx = this.add.graphics();
    gfx.setDepth(-1); // Behind everything
    for (let i = 0; i < 150; i++) {
      const x = Phaser.Math.Between(0, GAME_WIDTH);
      const y = Phaser.Math.Between(0, GAME_HEIGHT);
      const size = Phaser.Math.FloatBetween(0.5, 2);
      const brightness = Phaser.Math.FloatBetween(0.3, 1);
      gfx.fillStyle(Phaser.Display.Color.GetColor(
        Math.floor(255 * brightness),
        Math.floor(255 * brightness),
        Math.floor(255 * brightness)
      ), 1);
      gfx.fillCircle(x, y, size);
    }
    // Add a few colored stars for variety
    for (let i = 0; i < 15; i++) {
      const x = Phaser.Math.Between(0, GAME_WIDTH);
      const y = Phaser.Math.Between(0, GAME_HEIGHT);
      gfx.fillStyle(Phaser.Math.Between(0, 1) ? 0x88ccff : 0xffcc88, 0.6);
      gfx.fillCircle(x, y, Phaser.Math.FloatBetween(1, 2.5));
    }
  }

  // ----------------------------------------------------------
  // Create the player ship texture (a triangle with a flame)
  // ----------------------------------------------------------
  createPlayerTexture() {
    const gfx = this.make.graphics({ x: 0, y: 0, add: false });
    // Ship body â€” a sleek triangle in cyan/blue
    gfx.fillStyle(0x00ddff, 1);
    gfx.beginPath();
    gfx.moveTo(20, 0);    // Nose of the ship (top center)
    gfx.lineTo(0, 40);    // Bottom-left
    gfx.lineTo(40, 40);   // Bottom-right
    gfx.closePath();
    gfx.fillPath();

    // Darker blue inner detail
    gfx.fillStyle(0x0088cc, 1);
    gfx.beginPath();
    gfx.moveTo(20, 8);
    gfx.lineTo(10, 35);
    gfx.lineTo(30, 35);
    gfx.closePath();
    gfx.fillPath();

    // Cockpit glow
    gfx.fillStyle(0xaaeeff, 1);
    gfx.fillCircle(20, 16, 4);

    // Engine flame â€” orange/yellow triangle at the bottom
    gfx.fillStyle(0xff8800, 0.9);
    gfx.beginPath();
    gfx.moveTo(14, 40);
    gfx.lineTo(20, 55);
    gfx.lineTo(26, 40);
    gfx.closePath();
    gfx.fillPath();

    // Inner flame â€” brighter yellow
    gfx.fillStyle(0xffdd00, 0.9);
    gfx.beginPath();
    gfx.moveTo(17, 40);
    gfx.lineTo(20, 50);
    gfx.lineTo(23, 40);
    gfx.closePath();
    gfx.fillPath();

    // Turn the drawing into a texture we can use as a sprite
    gfx.generateTexture('player', 40, 56);
    gfx.destroy();
  }

  // ----------------------------------------------------------
  // Create bullet texture (small bright yellow rectangle)
  // ----------------------------------------------------------
  createBulletTexture() {
    const gfx = this.make.graphics({ x: 0, y: 0, add: false });
    gfx.fillStyle(0xffff00, 1);
    gfx.fillRect(0, 0, 4, 12);
    // Add a bright white core
    gfx.fillStyle(0xffffff, 0.8);
    gfx.fillRect(1, 1, 2, 10);
    gfx.generateTexture('bullet', 4, 12);
    gfx.destroy();
  }

  // ----------------------------------------------------------
  // Create enemy textures (round alien shapes in red/orange)
  // We make 3 different sizes for variety
  // ----------------------------------------------------------
  createEnemyTextures() {
    const sizes = [
      { key: 'enemy_small', radius: 12, color: 0xff4444 },
      { key: 'enemy_medium', radius: 18, color: 0xff6600 },
      { key: 'enemy_large', radius: 24, color: 0xcc3300 }
    ];

    sizes.forEach(({ key, radius, color }) => {
      const dim = radius * 2 + 4; // Add padding
      const cx = dim / 2;
      const cy = dim / 2;
      const gfx = this.make.graphics({ x: 0, y: 0, add: false });

      // Outer glow
      gfx.fillStyle(color, 0.3);
      gfx.fillCircle(cx, cy, radius + 2);

      // Main body
      gfx.fillStyle(color, 1);
      gfx.fillCircle(cx, cy, radius);

      // Darker inner circle for depth
      gfx.fillStyle(0x000000, 0.3);
      gfx.fillCircle(cx, cy, radius * 0.6);

      // "Eyes" â€” two small bright dots
      gfx.fillStyle(0xffffff, 0.9);
      gfx.fillCircle(cx - radius * 0.3, cy - radius * 0.15, radius * 0.18);
      gfx.fillCircle(cx + radius * 0.3, cy - radius * 0.15, radius * 0.18);

      // Pupils
      gfx.fillStyle(0x000000, 1);
      gfx.fillCircle(cx - radius * 0.25, cy - radius * 0.15, radius * 0.09);
      gfx.fillCircle(cx + radius * 0.35, cy - radius * 0.15, radius * 0.09);

      gfx.generateTexture(key, dim, dim);
      gfx.destroy();
    });
  }

  // ----------------------------------------------------------
  // Spawn an enemy at the top of the screen
  // ----------------------------------------------------------
  spawnEnemy() {
    if (this.gameOver) return;

    // Pick a random enemy size
    const types = ['enemy_small', 'enemy_medium', 'enemy_large'];
    const type = Phaser.Utils.Array.GetRandom(types);

    // Random horizontal position
    const x = Phaser.Math.Between(30, GAME_WIDTH - 30);

    // Create the enemy sprite
    const enemy = this.enemies.create(x, -30, type);
    enemy.setActive(true).setVisible(true);

    // Speed depends on difficulty level (gets faster over time)
    const baseSpeed = 80 + (this.difficultyLevel * 15);
    const speed = Phaser.Math.Between(baseSpeed, baseSpeed + 60);
    enemy.setVelocityY(speed);

    // Slight horizontal drift for variety
    enemy.setVelocityX(Phaser.Math.Between(-30, 30));

    // Points based on size (smaller = harder to hit = more points)
    if (type === 'enemy_small') enemy.pointValue = 30;
    else if (type === 'enemy_medium') enemy.pointValue = 20;
    else enemy.pointValue = 10;
  }

  // ----------------------------------------------------------
  // Increase the difficulty (called every 15 seconds)
  // ----------------------------------------------------------
  increaseDifficulty() {
    if (this.gameOver) return;
    this.difficultyLevel++;

    // Spawn enemies more frequently (but not too fast)
    const newDelay = Math.max(300, 1200 - (this.difficultyLevel * 100));
    this.enemySpawnTimer.delay = newDelay;
  }

  // ----------------------------------------------------------
  // Fire a bullet from the player's position
  // ----------------------------------------------------------
  fireBullet() {
    if (this.gameOver) return;

    const now = this.time.now;
    if (now - this.lastFired < FIRE_RATE) return; // Rate limit

    // Get a bullet from the pool (or create one)
    const bullet = this.bullets.get(this.player.x, this.player.y - 20);
    if (!bullet) return; // Pool is full

    bullet.setActive(true).setVisible(true);
    bullet.body.enable = true;
    bullet.setVelocityY(-BULLET_SPEED); // Fly upward
    this.lastFired = now;

    // Play the "pew" sound
    try { this.playShootSound(); } catch (e) { /* audio not ready */ }
  }

  // ----------------------------------------------------------
  // Called when a bullet hits an enemy
  // ----------------------------------------------------------
  bulletHitEnemy(bullet, enemy) {
    // Deactivate both the bullet and the enemy
    bullet.setActive(false).setVisible(false);
    bullet.body.enable = false;
    bullet.setVelocity(0, 0);

    // Award points
    this.score += (enemy.pointValue || 10);
    this.scoreText.setText('Score: ' + this.score);

    // Create a particle explosion at the enemy's position
    this.createExplosion(enemy.x, enemy.y);

    // Remove the enemy
    enemy.destroy();

    // Play explosion sound
    try { this.playExplosionSound(); } catch (e) { /* audio not ready */ }
  }

  // ----------------------------------------------------------
  // Called when an enemy collides with the player
  // ----------------------------------------------------------
  enemyHitPlayer(player, enemy) {
    if (this.isInvincible || this.gameOver) return;

    // Remove the enemy
    this.createExplosion(enemy.x, enemy.y);
    enemy.destroy();

    // Lose a life
    this.lives--;
    this.livesText.setText(this.getLivesString());

    // Screen shake effect!
    this.cameras.main.shake(200, 0.015);

    // Play explosion sound
    try { this.playExplosionSound(); } catch (e) { /* audio not ready */ }

    if (this.lives <= 0) {
      // Game over!
      this.triggerGameOver();
    } else {
      // Brief invincibility so the player has time to recover
      this.isInvincible = true;
      // Flash the player to show they're invincible
      this.tweens.add({
        targets: player,
        alpha: { from: 0.2, to: 1 },
        duration: 150,
        repeat: 6,
        onComplete: () => {
          this.isInvincible = false;
          player.setAlpha(1);
        }
      });
    }
  }

  // ----------------------------------------------------------
  // Create a particle burst explosion at (x, y)
  // ----------------------------------------------------------
  createExplosion(x, y) {
    // Create several small particles that fly outward
    const colors = [0xff4444, 0xff8800, 0xffdd00, 0xffffff];
    for (let i = 0; i < 10; i++) {
      const gfx = this.add.graphics();
      const color = Phaser.Utils.Array.GetRandom(colors);
      const size = Phaser.Math.Between(2, 5);
      gfx.fillStyle(color, 1);
      gfx.fillCircle(0, 0, size);
      gfx.setPosition(x, y);
      gfx.setDepth(5);
      this.particles.add(gfx);

      // Fly in a random direction and fade out
      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);
      const speed = Phaser.Math.Between(60, 180);
      const dx = Math.cos(angle) * speed;
      const dy = Math.sin(angle) * speed;

      this.tweens.add({
        targets: gfx,
        x: gfx.x + dx * 0.4,
        y: gfx.y + dy * 0.4,
        alpha: 0,
        duration: Phaser.Math.Between(200, 500),
        onComplete: () => { gfx.destroy(); }
      });
    }
  }

  // ----------------------------------------------------------
  // Return a string of heart emojis for the HUD
  // ----------------------------------------------------------
  getLivesString() {
    return 'â¤ï¸'.repeat(this.lives);
  }

  // ----------------------------------------------------------
  // End the game and show the Game Over screen
  // ----------------------------------------------------------
  triggerGameOver() {
    this.gameOver = true;
    this.physics.pause(); // Stop all physics

    // Play game over sound
    try { this.playGameOverSound(); } catch (e) { /* audio not ready */ }

    // Dim the screen
    const overlay = this.add.rectangle(
      GAME_WIDTH / 2, GAME_HEIGHT / 2,
      GAME_WIDTH, GAME_HEIGHT,
      0x000000, 0.7
    ).setDepth(20);

    // "Game Over" text
    this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 - 80, 'ðŸ’¥ GAME OVER ðŸ’¥', {
      fontSize: '32px',
      fill: '#ff4444',
      fontFamily: 'monospace',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(21);

    // Final score
    this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 - 20, 'Score: ' + this.score, {
      fontSize: '28px',
      fill: '#ffffff',
      fontFamily: 'monospace'
    }).setOrigin(0.5).setDepth(21);

    // "Play Again" button
    const button = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 + 60, 'ðŸš€ Play Again ðŸš€', {
      fontSize: '24px',
      fill: '#00ddff',
      fontFamily: 'monospace',
      backgroundColor: '#003344',
      padding: { x: 20, y: 12 }
    }).setOrigin(0.5).setDepth(21).setInteractive({ useHandCursor: true });

    // Hover effect
    button.on('pointerover', () => button.setStyle({ fill: '#ffffff', backgroundColor: '#005566' }));
    button.on('pointerout', () => button.setStyle({ fill: '#00ddff', backgroundColor: '#003344' }));

    // Restart the game when clicked
    button.on('pointerdown', () => {
      this.scene.restart();
    });
  }

  // ----------------------------------------------------------
  // Create virtual touch controls for mobile devices
  // ----------------------------------------------------------
  createTouchControls() {
    const btnSize = 80;
    const padding = 15;
    const btnAlpha = 0.35;
    const btnDepth = 100;

    // --- D-pad: Left button ---
    const leftBtn = this.add.text(padding, GAME_HEIGHT - btnSize - padding, 'â¬…ï¸', {
      fontSize: '48px',
      backgroundColor: 'rgba(255,255,255,0.1)',
      padding: { x: 14, y: 10 }
    }).setDepth(btnDepth).setAlpha(btnAlpha).setScrollFactor(0).setInteractive();

    leftBtn.on('pointerdown', () => { this.touchControls.left = true; leftBtn.setAlpha(0.7); });
    leftBtn.on('pointerup', () => { this.touchControls.left = false; leftBtn.setAlpha(btnAlpha); });
    leftBtn.on('pointerout', () => { this.touchControls.left = false; leftBtn.setAlpha(btnAlpha); });

    // --- D-pad: Right button ---
    const rightBtn = this.add.text(padding + btnSize + 10, GAME_HEIGHT - btnSize - padding, 'âž¡ï¸', {
      fontSize: '48px',
      backgroundColor: 'rgba(255,255,255,0.1)',
      padding: { x: 14, y: 10 }
    }).setDepth(btnDepth).setAlpha(btnAlpha).setScrollFactor(0).setInteractive();

    rightBtn.on('pointerdown', () => { this.touchControls.right = true; rightBtn.setAlpha(0.7); });
    rightBtn.on('pointerup', () => { this.touchControls.right = false; rightBtn.setAlpha(btnAlpha); });
    rightBtn.on('pointerout', () => { this.touchControls.right = false; rightBtn.setAlpha(btnAlpha); });

    // --- D-pad: Up button ---
    const upBtn = this.add.text(padding + (btnSize + 10) / 2, GAME_HEIGHT - btnSize * 2 - padding - 10, 'â¬†ï¸', {
      fontSize: '48px',
      backgroundColor: 'rgba(255,255,255,0.1)',
      padding: { x: 14, y: 10 }
    }).setDepth(btnDepth).setAlpha(btnAlpha).setScrollFactor(0).setInteractive();

    upBtn.on('pointerdown', () => { this.touchControls.up = true; upBtn.setAlpha(0.7); });
    upBtn.on('pointerup', () => { this.touchControls.up = false; upBtn.setAlpha(btnAlpha); });
    upBtn.on('pointerout', () => { this.touchControls.up = false; upBtn.setAlpha(btnAlpha); });

    // --- D-pad: Down button ---
    const downBtn = this.add.text(padding + (btnSize + 10) / 2, GAME_HEIGHT - padding + 10, 'â¬‡ï¸', {
      fontSize: '48px',
      backgroundColor: 'rgba(255,255,255,0.1)',
      padding: { x: 14, y: 10 }
    }).setDepth(btnDepth).setAlpha(btnAlpha).setScrollFactor(0).setInteractive();

    downBtn.on('pointerdown', () => { this.touchControls.down = true; downBtn.setAlpha(0.7); });
    downBtn.on('pointerup', () => { this.touchControls.down = false; downBtn.setAlpha(btnAlpha); });
    downBtn.on('pointerout', () => { this.touchControls.down = false; downBtn.setAlpha(btnAlpha); });

    // --- Fire button (bottom-right) ---
    const fireBtn = this.add.text(GAME_WIDTH - btnSize - padding, GAME_HEIGHT - btnSize - padding - 20, 'ðŸ”¥', {
      fontSize: '52px',
      backgroundColor: 'rgba(255,50,50,0.15)',
      padding: { x: 12, y: 8 }
    }).setDepth(btnDepth).setAlpha(0.45).setScrollFactor(0).setInteractive();

    fireBtn.on('pointerdown', () => { this.touchControls.fire = true; fireBtn.setAlpha(0.8); });
    fireBtn.on('pointerup', () => { this.touchControls.fire = false; fireBtn.setAlpha(0.45); });
    fireBtn.on('pointerout', () => { this.touchControls.fire = false; fireBtn.setAlpha(0.45); });
  }

  // ----------------------------------------------------------
  // UPDATE: Runs every frame (~60 times per second).
  // Handles movement, shooting, and cleanup.
  // ----------------------------------------------------------
  update() {
    if (this.gameOver) return;

    // --- Player movement ---
    let vx = 0; // Horizontal velocity
    let vy = 0; // Vertical velocity

    // Check keyboard input (arrow keys or WASD)
    const leftPressed = this.cursors.left.isDown || this.wasd.left.isDown || this.touchControls.left;
    const rightPressed = this.cursors.right.isDown || this.wasd.right.isDown || this.touchControls.right;
    const upPressed = this.cursors.up.isDown || this.wasd.up.isDown || this.touchControls.up;
    const downPressed = this.cursors.down.isDown || this.wasd.down.isDown || this.touchControls.down;

    if (leftPressed) vx = -PLAYER_SPEED;
    else if (rightPressed) vx = PLAYER_SPEED;

    if (upPressed) vy = -PLAYER_SPEED;
    else if (downPressed) vy = PLAYER_SPEED;

    // Normalize diagonal movement so it's not faster
    if (vx !== 0 && vy !== 0) {
      vx *= 0.707; // 1 / sqrt(2)
      vy *= 0.707;
    }

    this.player.setVelocity(vx, vy);

    // --- Shooting ---
    if (this.spaceKey.isDown || this.touchControls.fire) {
      this.fireBullet();
    }

    // --- Clean up bullets that fly off-screen ---
    this.bullets.getChildren().forEach(bullet => {
      if (bullet.active && bullet.y < -20) {
        bullet.setActive(false).setVisible(false);
        bullet.body.enable = false;
        bullet.setVelocity(0, 0);
      }
    });

    // --- Clean up enemies that fall off the bottom ---
    this.enemies.getChildren().forEach(enemy => {
      if (enemy.active && enemy.y > GAME_HEIGHT + 50) {
        enemy.destroy();
      }
    });
  }
}

// ============================================================
// PHASER GAME CONFIGURATION
// ============================================================
const config = {
  type: Phaser.AUTO,               // Auto-detect WebGL or Canvas
  width: GAME_WIDTH,
  height: GAME_HEIGHT,
  parent: document.body,
  backgroundColor: '#0a0a1a',      // Very dark blue-black
  physics: {
    default: 'arcade',             // Simple arcade physics
    arcade: {
      debug: false                 // Set to true to see hitboxes
    }
  },
  scale: {
    mode: Phaser.Scale.FIT,        // Scale to fit the screen
    autoCenter: Phaser.Scale.CENTER_BOTH, // Center the game
    max: {
      width: GAME_WIDTH,
      height: GAME_HEIGHT
    }
  },
  scene: [GameScene]               // Our game scene
};

// --- Start the game! ---
const game = new Phaser.Game(config);
</script>

</body>
</html>
